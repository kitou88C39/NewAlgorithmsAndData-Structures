import java.util.Scanner;

public class Main {

    // 配列の内容を出力するヘルパー関数 (今回は不要だが残しておく)
    static void print(int a[], int n) {
        for (int i = 0; i < n; i++) {
            if (i > 0)
                System.out.print(" ");
            System.out.print(a[i]);
        }
        System.out.println();
    }

    // gap付き挿入ソート (要素の移動回数を返すように変更)
    static int insertionSort(int a[], int n, int h) { // intを返すように変更
        int numOfMove = 0; // このgapでの移動回数

        // i は h から n-1 まで (h個飛ばしで未ソート部分の要素を取り出す)
        for (int i = h; i < n; i++) {
            int x = a[i]; // 挿入する要素
            int j = i;    // 挿入位置を探すためのインデックス

            // j が h 以上 かつ a[j-h] が x より大きい間 (xを挿入するスペースを作るため)
            while (j >= h && a[j - h] > x) { // ★修正点1: 条件を j >= h に変更
                a[j] = a[j - h];             // ★修正点2: a[j-h] を a[j] にずらす
                j -= h;                      // h 間隔でインデックスを左に移動
                numOfMove++;                 // 移動回数をカウント
            }

            // x を適切な位置に挿入
            a[j] = x;
        }
        return numOfMove; // このgapでの移動回数を返す
    }

    // シェルソートのメインロジック (合計移動回数を集計するように変更)
    static void shellSort(int a[], int n, int[] h, int k) {
        int totalNumOfMove = 0; // 全体の移動回数を集計する変数

        // 間隔 h の配列を順番に適用
        for (int i = 0; i < k; i++) {
            // 各間隔 h[i] で挿入ソートを呼び出し、移動回数を加算
            totalNumOfMove += insertionSort(a, n, h[i]); // ★修正点3: 戻り値を受け取る
        }

        // 全体の移動回数を出力
        System.out.println(totalNumOfMove); // ★修正点4: ここで一度だけ出力
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 数列の要素数 n を読み込む

        int a[] = new int[n]; // 要素数 n の整数配列 a を宣言
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt(); // 配列 a の各要素を読み込む
        }

        int k = sc.nextInt(); // 間隔列 h の要素数 k を読み込む

        int h[] = new int[k]; // 間隔列 h を宣言
        for (int i = 0; i < k; i++) {
            h[i] = sc.nextInt(); // 間隔列 h の各要素を読み込む
        }

        shellSort(a, n, h, k); // シェルソートを実行

        sc.close(); // Scannerのリソースを解放
    }
}